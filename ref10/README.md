# Extracting ref10 from SUPERCOP

To implement XEdDSA, access to low-level cryptographic functions is required, which are usually not exported by crypto-libraries.

ref10 by D. J. Bernstein is a solid implementation of these low-level functions. It comes as part of the [SUPERCOP](https://bench.cr.yp.to/supercop.html) benchmark and is not available as a standalone library.

This little guide explains the steps I did to extract the ref10 implementation from the SUPERCOP benchmarking system.

__NOTE__: The SUPERCOP benchmark assumes a Linux system and so does this guide. The steps explain how to extract the required C source code and how to compile it into shared object files. The source code is mostly os-independent, only the kernelrandombytes module uses os-specific code to retrieve cryptographically secure random data. Any Windows dev with a bit of experience should be able to build a DLL from the source code.

__NOTE__: This guide assumes a 64 bit operating system.

### 1. Download and run the benchmark

The first step is to download and run the benchmark. The benchmark generates some files on-the-fly, based on your os/system architecture. We need some of these generated files to build ref10 standalone, that's why the benchmark has to run first. Note that the benchmark is HUGE and it may take multiple days to finish one run. Follow the instructions [here](https://bench.cr.yp.to/supercop.html) to run the "Alternative: Incremental benchmarks".

__NOTE__: Consider actually closing all other applications and running the benchmark as intended, look at the SUPERCOP website for additional information.

### 2. Extract the ref10 source code

After running the benchmark you should have a `supercop-YYYYMMDD` directory with the original benchmark files and a `supercop-data` directory with the results of your run. We will need files from both of these directories, the first one will be referred to as the base directory and the second one as the data directory.

Only one module is required to implement XEdDSA: The crypto_sign module for the ed25519 signature scheme. For completeness this guide also covers how to extract the second part of the ref10 implementation: crypto_scalarmult for curve25519. The following steps explain how to compile shared object files for each of these two modules.

### 2.1. crypto_scalarmult

The ref10 source code for the crypto_scalarmult module can be found in the base directory, following `crypto_scalarmult/curve25519/ref10`.

D. J. Bernstein uses scripts to generate some of his files, one of the tools he's using is called `qhasm`.
Other files are generated by Python scripts.
Luckily, he uploaded the generated files, so we don't have to install qhasm and reproduce this step.

For that reason, we can delete his Makefiles and everything else related to qhasm and Python:

- All `*.do` files
- All `*.q` files
- All `*.py` files
- The Makefiles

The remaining files are almost enough to generate the shared object for this module, just a few files generated by the benchmark are missing.

A couple of files that define fixed-size integers are missing. Those are located inside of your data directory, following the path `inttypes/include/amd64`.

Now just two more header files are missing: `crypto_scalarmult.h` and `crypto_scalarmult_curve25519.h`. The benchmark runs each module with a set of different compiler arguments, e.g. with different optimization levels. It creates a unique directory for each of the configurations, located inside of your data directory. The benchmark puts additional generated header files into these directores, including the two headers for the crypto_scalarmult module. The full path to the header files looks like this: `amd64/try/c/<configuration>/crypto_scalarmult/curve25519/ref10/compiled`. It does not matter which configuration you look at, the headers are the same for all of them.

These are the three locations that contain all the code required to build the shared object file. Either copy all files into one directory or tell your compiler where to look for the files.

Possible commands to build the shared object:

```bash
$ gcc -Wall -Werror -g -Iinttypes -c -fpic -x c *.c
$ gcc -Wall -Werror -g -shared -Wl,--no-undefined -o crypto_scalarmult.so *.o
```

### 2.2. crypto_sign

The crypto_sign module is a lot trickier, because it has quite a few dependencies. Most of these are easy to build though. crypto_sign needs:

- An implementation of sha512
- An implementation of 32 byte verification
- A random number source

The benchmark comes with multiple implementations for each of these dependencies and automatically selects the best performing one. This guide focusses on portable implementations, using ref10 or its predecessor ref whenever possible.

### 2.2.1. Collecting dependencies

Some of the dependencies have more dependencies themselves. The next section creates a summary of all modules that need to be built.

#### sha512

The benchmark comes with a ref implementation of sha512, which is located in `crypto_hash/sha512/ref`. This implementation uses another module: sha512 hashblocks, which comes with a ref implementation aswell (`crypto_hashblocks/sha512/ref`).

#### 32 byte verification

The only implementation available for 32 byte verification is a ref implementation found in `crypto_verify/32/ref`.

#### random number source

The `fastrandombytes` module generates random data by initializing a stream cipher using just a few secure bytes retrieved from the os. It depends on `kernelrandombytes` to get secure bytes from the os and on `crypto_rng` to generate more random data from the kernel bytes. `fastrandombytes` and `kernelrandombytes` each are fixed implementations. `crypto_rng` comes with multiple different implementations again.

#### crypto_rng

This guide uses the salsa20 rng, because all parts are available as ref implementations. The module path is `crypto_rng/salsa20/ref`, which depends on a salsa20 stream cipher implementation.

#### salsa20 stream cipher

Again, a ref implementation, located at `crypto_stream/salsa20/ref`, which depends on a salsa20 implementation.

#### salsa20

This is the last one! Another ref implementation, located at `crypto_core/salsa20/ref`.

### 2.2.2. Dependencies summarized

Following modules can all be compiled the same way:

- `crypto_hash/sha512/ref`
- `crypto_hashblocks/sha512/ref`
- `crypto_verify/32/ref`
- `crypto_rng/salsa20/ref`
- `crypto_stream/salsa20/ref`
- `crypto_core/salsa20/ref`
- `fastrandombytes`

The only module that needs special treatment is `kernelrandombytes`.

### 2.2.3. The easy ones

The easiest way to build the dependencies is to compile (not link!) them and archive them into static libraries. That way we can process each module on its own without caring about dependencies.

The source code for each of these modules is split into two locations, with the exception of `fastrandombytes`, which has all of its sources in the base directory:

- The main sources in the base directory
- The additional generated sources in the data directory

These commands show how to build the static library for `crypto_hash/sha512/ref`, it works just the same way for the other modules:

```bash
$ # Copy the main source files into a new directory
$ cp -r <base>/crypto_hash/sha512/ref/ sha512
$ cd sha512
$ # Copy the additional generated source, if necessary
$ cp <data>/amd64/try/c/gcc/crypto_hash/sha512/ref/compiled/crypto_hash.h .
$ cp <data>/amd64/try/c/gcc/crypto_hash/sha512/ref/compiled/crypto_hash_sha512.h .
$ # Compile the source files into object files
$ gcc -Wall -Werror -g -c -fpic -x c *.c
$ # Package the object files into a static library
$ ar rcs crypto_hash.a *.o
```

Use the `-I<path>` option to tell gcc where to find missing headers.

### 2.2.4. `kernelrandombytes`

The `kernelrandombytes` module is the only one containing os-dependent code. It contains different implementations of the same function, where each implementation uses different apis that may be available on some operating system and may not be available on other ones. The idea is to just use the first file that compiles successfully. Only use the `urandom.c` file if all other options fail on your os, it is the least stable/secure one. [This article](https://lwn.net/Articles/606141/) has an interesting explanation, why using system calls is better then relying on `/dev/urandom`.

### 2.2.5. Putting it all together

Now you should have a load of static library files, ready to be linked together!

As usual the crypto_sign module has its main sources in the base directory, located at `crypto_sign/ed25519/ref10` and some benchmark generated source found in your data directory.

The sources include a `fe.h` header file. This file contains declarations for two external functions `fe_cswap` and `fe_mul121666`, which neither exist nor are being used by the remaining code. These were probably included by accident. Some systems, such as [cffi](https://bitbucket.org/cffi/cffi/), may get confused by these orphaned declarations. To fix this, just delete the following lines from the header:

```cpp
...
#define fe_cswap crypto_sign_ed25519_ref10_fe_cswap
...
#define fe_mul121666 crypto_sign_ed25519_ref10_fe_mul121666
...
extern void fe_cswap(fe,fe,unsigned int);
...
extern void fe_mul121666(fe,const fe);
...
```

Finally, build the shared object file using following commands:

```bash
$ gcc -Wall -Werror -g -Iinttypes -Icrypto_hash -c -fpic -x c *.c
$ gcc -Wall -Werror -g -shared -Wl,--no-undefined -o crypto_sign.so *.o -l:crypto_hash.a -l:crypto_hashblocks.a -l:crypto_verify.a -l:fastrandombytes.a -l:kernelrandombytes.a -l:crypto_rng.a -l:crypto_stream.a -l:crypto_core.a
```
